/**
 * @fileoverview Transforms `import localName from "external_module"` to
 * `const localName = global_name_for_the_external_module`.
 * Also transforms `import tslib_any from 'tslib'` to `goog.require("tslib")`.
 */
import ITsccSpecWithTS from './spec/ITsccSpecWithTS';
import {TsickleHost} from 'tsickle';
import {moduleNameAsIdentifier} from 'tsickle/src/annotator_host';

export function getExternsForExternalModules(tsccSpec: ITsccSpecWithTS, tsickleHost: TsickleHost): string {
	const moduleNames = tsccSpec.getExternalModuleNames();
	const toGlobalName = tsccSpec.getExternalModuleNamesToGlobalsMap();
	const header = `\n/** Generated by TSCC */`
	let out = '';
	for (let moduleName of moduleNames) {
		// If a module's type definition is from node_modules, its path is used as a namespace.
		// otherwise, it comes from declare module '...' in user-provided files, in which the module name string
		// is used as a namespace.
		let typeRefFile = tsccSpec.resolveExternalModuleTypeReference(moduleName) || moduleName;
		out += `
/** 
 * @type{${moduleNameAsIdentifier(tsickleHost, typeRefFile)}}
 * @const
 */
${tsickleHost.es5Mode ? 'var' : 'const'} ${toGlobalName[moduleName]} = {};\n`;
	}
	if (out.length) out = header + out;
	return out;
}

export function getGluingModules(tsccSpec: ITsccSpecWithTS, tsickleHost: TsickleHost) {
	const moduleNames = tsccSpec.getExternalModuleNames();
	const toGlobalName = tsccSpec.getExternalModuleNamesToGlobalsMap();
	const out: {path: string, content: string}[] = [];
	for (let moduleName of moduleNames) {
		const content = `goog.module('${moduleName.replace(/([\\'])/g, '\\$1')}')\n` +
			`/** Generated by TSCC */\n` +
			`exports = ${toGlobalName[moduleName]};`;
		// A hypothetical path of this gluing module. 
		let path = tsccSpec.resolveExternalModuleTypeReference(moduleName) || moduleName;
		path = path.replace(/(?:\.d)?\.ts$/, '.js');
		out.push({path, content});
	}
	return out;
}

